diff --git a/Source/CMakeLists.txt b/Source/CMakeLists.txt
index 9d0a528694fa..c780aa70538a 100644
--- a/Source/CMakeLists.txt
+++ b/Source/CMakeLists.txt
@@ -54,4 +54,6 @@ if (ENABLE_WEBDRIVER)
     add_subdirectory(WebDriver)
 endif ()
 
+add_subdirectory(WebGPU)
+
 WEBKIT_INCLUDE_CONFIG_FILES_IF_EXISTS()
diff --git a/Source/JavaScriptCore/Sources.txt b/Source/JavaScriptCore/Sources.txt
index 63ebb5c1e740..37bd43746ab2 100644
--- a/Source/JavaScriptCore/Sources.txt
+++ b/Source/JavaScriptCore/Sources.txt
@@ -523,6 +523,8 @@ ftl/FTLState.cpp
 ftl/FTLThunks.cpp
 ftl/FTLValueRange.cpp
 
+fuzzilli/Fuzzilli.cpp
+
 heap/AlignedMemoryAllocator.cpp
 heap/Allocator.cpp
 heap/BlockDirectory.cpp
diff --git a/Source/JavaScriptCore/fuzzilli/Fuzzilli.cpp b/Source/JavaScriptCore/fuzzilli/Fuzzilli.cpp
index f17d1b43b605..03e4beb40006 100644
--- a/Source/JavaScriptCore/fuzzilli/Fuzzilli.cpp
+++ b/Source/JavaScriptCore/fuzzilli/Fuzzilli.cpp
@@ -27,6 +27,10 @@
 #include <wtf/DataLog.h>
 #include <wtf/NeverDestroyed.h>
 
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
 #if ENABLE(FUZZILLI)
 
 #define REPRL_CRFD 100
@@ -109,7 +113,18 @@ void Fuzzilli::readInput(Vector<char>* buffer)
     RELEASE_ASSERT(inputSize < REPRL_MAX_DATA_SIZE);
 
     buffer->resize(inputSize);
-    memcpy(buffer->data(), reprlInputData, inputSize);
+    //memcpy(buffer->data(), reprlInputData, inputSize);
+    char* ptr = buffer->data();
+    size_t remaining = inputSize;
+    while (remaining > 0) {
+        ssize_t rv = read(REPRL_DRFD, ptr, remaining);
+        if (rv <= 0) {
+          fprintf(stderr, "Failed to load script\n");
+          _exit(-1);
+        }
+        remaining -= rv;
+        ptr += rv;
+    }
 }
 
 void Fuzzilli::flushReprl(int32_t result)
@@ -141,8 +156,8 @@ void Fuzzilli::initializeReprl()
     RELEASE_ASSERT_WITH_MESSAGE(!memcmp(helo, "HELO", 4), "[REPRL] Invalid response from parent");
 
     // Mmap the data input buffer.
-    reprlInputData = static_cast<char*>(mmap(0, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, REPRL_DRFD, 0));
-    RELEASE_ASSERT(reprlInputData != MAP_FAILED);
+    //reprlInputData = static_cast<char*>(mmap(0, REPRL_MAX_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, REPRL_DRFD, 0));
+    //RELEASE_ASSERT(reprlInputData != MAP_FAILED);
 }
 
 
@@ -170,4 +185,5 @@ extern "C" void __sanitizer_cov_trace_pc_guard(uint32_t* guard)
     *guard = 0;
 }
 
+#else
 #endif // ENABLE(FUZZILLI)
diff --git a/Source/JavaScriptCore/fuzzilli/Fuzzilli.h b/Source/JavaScriptCore/fuzzilli/Fuzzilli.h
index 4ac07e148cd2..0148ed5a7b6c 100644
--- a/Source/JavaScriptCore/fuzzilli/Fuzzilli.h
+++ b/Source/JavaScriptCore/fuzzilli/Fuzzilli.h
@@ -60,4 +60,5 @@ void initializeReprl();
 
 } // namespace Fuzzilli
 
+#else
 #endif // ENABLE(FUZZILLI)
diff --git a/Source/JavaScriptCore/jsc.cpp b/Source/JavaScriptCore/jsc.cpp
index de2913949d51..62296df1171a 100644
--- a/Source/JavaScriptCore/jsc.cpp
+++ b/Source/JavaScriptCore/jsc.cpp
@@ -3300,6 +3300,11 @@ JSC_DEFINE_HOST_FUNCTION(functionFuzzilli, (JSGlobalObject* globalObject, CallFr
         case 2:
             ASSERT(0);
             break;
+        case 3:
+            char* ptr = (char*)malloc(2);
+            free(ptr);
+            ((volatile char*)(ptr))[0] = 0;
+            break;
         }
 
     } else if (operation == "FUZZILLI_PRINT"_s) {
diff --git a/Source/WTF/wtf/Assertions.cpp b/Source/WTF/wtf/Assertions.cpp
index 4e9b3798c6ca..382b2c047566 100644
--- a/Source/WTF/wtf/Assertions.cpp
+++ b/Source/WTF/wtf/Assertions.cpp
@@ -348,6 +348,7 @@ void WTFCrash()
 #if ASAN_ENABLED
     __builtin_trap();
 #else
+    //#error "need asan"
     *(int *)(uintptr_t)0xbbadbeef = 0;
     // More reliable, but doesn't say BBADBEEF.
 #if COMPILER(GCC) || COMPILER(CLANG)
diff --git a/Source/WebGPU/CMakeLists.txt b/Source/WebGPU/CMakeLists.txt
new file mode 100644
index 000000000000..fbefbc738a5e
--- /dev/null
+++ b/Source/WebGPU/CMakeLists.txt
@@ -0,0 +1 @@
+add_subdirectory(WGSL)
diff --git a/Source/WebGPU/WGSL/CMakeLists.txt b/Source/WebGPU/WGSL/CMakeLists.txt
new file mode 100644
index 000000000000..927a23ff58b1
--- /dev/null
+++ b/Source/WebGPU/WGSL/CMakeLists.txt
@@ -0,0 +1,55 @@
+#set_property(DIRECTORY . PROPERTY FOLDER "WebGPU")
+
+set(wgslfuzz_PRIVATE_INCLUDE_DIRECTORIES
+    "${CMAKE_BINARY_DIR}"
+)
+list(APPEND wgslfuzz_PRIVATE_INCLUDE_DIRECTORIES
+    "${CMAKE_CURRENT_SOURCE_DIR}")
+list(APPEND wgslfuzz_PRIVATE_INCLUDE_DIRECTORIES
+    "${CMAKE_CURRENT_SOURCE_DIR}/AST")
+
+set(wgslfuzz_SOURCES
+    wgslfuzz.cpp
+    AttributeValidator.cpp
+    BoundsCheck.cpp
+    CallGraph.cpp
+    CompilationMessage.cpp
+    CompilationScope.cpp
+    ConstantValue.cpp
+    Constraints.cpp
+    EntryPointRewriter.cpp
+    GlobalSorting.cpp
+    GlobalVariableRewriter.cpp
+    Lexer.cpp
+    MangleNames.cpp
+    Overload.cpp
+    Parser.cpp
+    PointerRewriter.cpp
+    Token.cpp
+    TypeCheck.cpp
+    Types.cpp
+    TypeStore.cpp
+    wgslc.cpp
+    WGSL.cpp
+    WGSLEnums.cpp
+    AST/ASTBinaryExpression.cpp
+    AST/ASTBuilder.cpp
+    AST/ASTDecrementIncrementStatement.cpp
+    AST/ASTStringDumper.cpp
+    AST/ASTUnaryExpression.cpp
+    AST/ASTVisitor.cpp
+    Metal/MetalCodeGenerator.cpp
+    Metal/MetalFunctionWriter.cpp
+)
+
+set(wgslfuzz_FRAMEWORKS
+    WTF
+)
+
+if (NOT USE_SYSTEM_MALLOC)
+    list(APPEND wgslfuzz_FRAMEWORKS bmalloc)
+endif ()
+
+WEBKIT_EXECUTABLE_DECLARE(wgslfuzz)
+
+WEBKIT_EXECUTABLE(wgslfuzz)
diff --git a/Source/WebGPU/WGSL/ConstantFunctions.h b/Source/WebGPU/WGSL/ConstantFunctions.h
index c3d991884115..43bb29d12c1f 100644
--- a/Source/WebGPU/WGSL/ConstantFunctions.h
+++ b/Source/WebGPU/WGSL/ConstantFunctions.h
@@ -758,7 +758,7 @@ CONSTANT_FUNCTION(BitwiseShiftRight)
 
 CONSTANT_CONSTRUCTOR(Bool, bool)
 CONSTANT_CONSTRUCTOR(F32, float)
-CONSTANT_CONSTRUCTOR(F16, half)
+//CONSTANT_CONSTRUCTOR(F16, half)
 
 CONSTANT_FUNCTION(I32)
 {
@@ -1033,23 +1033,23 @@ CONSTANT_FUNCTION(Dot)
     return { { result } };
 }
 
-CONSTANT_FUNCTION(Dot4U8Packed)
-{
-    UNUSED_PARAM(resultType);
-    auto lhs = bitwise_cast<std::array<uint8_t, 4>>(std::get<uint32_t>(arguments[0]));
-    auto rhs = bitwise_cast<std::array<uint8_t, 4>>(std::get<uint32_t>(arguments[1]));
-    uint32_t result = lhs[0] * rhs[0] + lhs[1] * rhs[1] + lhs[2] * rhs[2] + lhs[3] * rhs[3];
-    return { { result } };
-}
-
-CONSTANT_FUNCTION(Dot4I8Packed)
-{
-    UNUSED_PARAM(resultType);
-    auto lhs = bitwise_cast<std::array<int8_t, 4>>(std::get<uint32_t>(arguments[0]));
-    auto rhs = bitwise_cast<std::array<int8_t, 4>>(std::get<uint32_t>(arguments[1]));
-    int32_t result = lhs[0] * rhs[0] + lhs[1] * rhs[1] + lhs[2] * rhs[2] + lhs[3] * rhs[3];
-    return { { result } };
-}
+//CONSTANT_FUNCTION(Dot4U8Packed)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto lhs = bitwise_cast<std::array<uint8_t, 4>>(std::get<uint32_t>(arguments[0]));
+//    auto rhs = bitwise_cast<std::array<uint8_t, 4>>(std::get<uint32_t>(arguments[1]));
+//    uint32_t result = lhs[0] * rhs[0] + lhs[1] * rhs[1] + lhs[2] * rhs[2] + lhs[3] * rhs[3];
+//    return { { result } };
+//}
+//
+//CONSTANT_FUNCTION(Dot4I8Packed)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto lhs = bitwise_cast<std::array<int8_t, 4>>(std::get<uint32_t>(arguments[0]));
+//    auto rhs = bitwise_cast<std::array<int8_t, 4>>(std::get<uint32_t>(arguments[1]));
+//    int32_t result = lhs[0] * rhs[0] + lhs[1] * rhs[1] + lhs[2] * rhs[2] + lhs[3] * rhs[3];
+//    return { { result } };
+//}
 
 CONSTANT_FUNCTION(Sqrt);
 
@@ -1459,202 +1459,202 @@ CONSTANT_FUNCTION(Transpose)
 UNARY_OPERATION(Trunc, Float, WRAP_STD(trunc))
 
 // Data Packing
-CONSTANT_FUNCTION(Pack4x8snorm)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<int8_t, 4> packed;
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = std::get<float>(vector.elements[i]);
-        packed[i] = static_cast<int8_t>(std::floor(0.5 + 127 * std::min(1.f, std::max(-1.f, e))));
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack4x8unorm)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<uint8_t, 4> packed;
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = std::get<float>(vector.elements[i]);
-        packed[i] = static_cast<uint8_t>(std::floor(0.5 + 255 * std::min(1.f, std::max(0.f, e))));
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack4xI8)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<uint8_t, 4> packed;
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = std::get<int32_t>(vector.elements[i]);
-        packed[i] = static_cast<uint8_t>(e);
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack4xU8)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<uint8_t, 4> packed;
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = std::get<uint32_t>(vector.elements[i]);
-        packed[i] = static_cast<uint8_t>(e);
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack4xI8Clamp)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<uint8_t, 4> packed;
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = std::get<int32_t>(vector.elements[i]);
-        packed[i] = static_cast<uint8_t>(std::min(127, std::max(-128, e)));
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack4xU8Clamp)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<uint8_t, 4> packed;
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = std::get<uint32_t>(vector.elements[i]);
-        packed[i] = static_cast<uint8_t>(std::min(255u, e));
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack2x16snorm)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<int16_t, 2> packed;
-    for (unsigned i = 0; i < 2; ++i) {
-        auto e = std::get<float>(vector.elements[i]);
-        packed[i] = static_cast<int16_t>(std::floor(0.5 + 32767 * std::min(1.f, std::max(-1.f, e))));
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack2x16unorm)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<uint16_t, 2> packed;
-    for (unsigned i = 0; i < 2; ++i) {
-        auto e = std::get<float>(vector.elements[i]);
-        packed[i] = static_cast<uint16_t>(std::floor(0.5 + 65535 * std::min(1.f, std::max(0.f, e))));
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
-CONSTANT_FUNCTION(Pack2x16float)
-{
-    UNUSED_PARAM(resultType);
-    auto& vector = std::get<ConstantVector>(arguments[0]);
-    std::array<half, 2> packed;
-    for (unsigned i = 0; i < 2; ++i) {
-        auto e = std::get<float>(vector.elements[i]);
-        auto converted = convertFloat<half>(e);
-        if (!converted)
-            return makeUnexpected(makeString("value ", String::number(e), " cannot be represented as 'f16'"));
-        packed[i] = *converted;
-    }
-    return { { bitwise_cast<uint32_t>(packed) } };
-}
-
+//CONSTANT_FUNCTION(Pack4x8snorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<int8_t, 4> packed;
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = std::get<float>(vector.elements[i]);
+//        packed[i] = static_cast<int8_t>(std::floor(0.5 + 127 * std::min(1.f, std::max(-1.f, e))));
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack4x8unorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<uint8_t, 4> packed;
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = std::get<float>(vector.elements[i]);
+//        packed[i] = static_cast<uint8_t>(std::floor(0.5 + 255 * std::min(1.f, std::max(0.f, e))));
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack4xI8)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<uint8_t, 4> packed;
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = std::get<int32_t>(vector.elements[i]);
+//        packed[i] = static_cast<uint8_t>(e);
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack4xU8)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<uint8_t, 4> packed;
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = std::get<uint32_t>(vector.elements[i]);
+//        packed[i] = static_cast<uint8_t>(e);
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack4xI8Clamp)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<uint8_t, 4> packed;
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = std::get<int32_t>(vector.elements[i]);
+//        packed[i] = static_cast<uint8_t>(std::min(127, std::max(-128, e)));
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack4xU8Clamp)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<uint8_t, 4> packed;
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = std::get<uint32_t>(vector.elements[i]);
+//        packed[i] = static_cast<uint8_t>(std::min(255u, e));
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack2x16snorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<int16_t, 2> packed;
+//    for (unsigned i = 0; i < 2; ++i) {
+//        auto e = std::get<float>(vector.elements[i]);
+//        packed[i] = static_cast<int16_t>(std::floor(0.5 + 32767 * std::min(1.f, std::max(-1.f, e))));
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack2x16unorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<uint16_t, 2> packed;
+//    for (unsigned i = 0; i < 2; ++i) {
+//        auto e = std::get<float>(vector.elements[i]);
+//        packed[i] = static_cast<uint16_t>(std::floor(0.5 + 65535 * std::min(1.f, std::max(0.f, e))));
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
+//CONSTANT_FUNCTION(Pack2x16float)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto& vector = std::get<ConstantVector>(arguments[0]);
+//    std::array<half, 2> packed;
+//    for (unsigned i = 0; i < 2; ++i) {
+//        auto e = std::get<float>(vector.elements[i]);
+//        auto converted = convertFloat<half>(e);
+//        if (!converted)
+//            return makeUnexpected(makeString("value ", String::number(e), " cannot be represented as 'f16'"));
+//        packed[i] = *converted;
+//    }
+//    return { { bitwise_cast<uint32_t>(packed) } };
+//}
+//
 // Data Unpacking
-CONSTANT_FUNCTION(Unpack4x8snorm)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<int8_t, 4>>(argument);
-    ConstantVector result(4);
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = static_cast<float>(packed[i]);
-        result.elements[i] = std::max(e / 127.f, -1.f);
-    }
-    return { result };
-}
-
-CONSTANT_FUNCTION(Unpack4x8unorm)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<uint8_t, 4>>(argument);
-    ConstantVector result(4);
-    for (unsigned i = 0; i < 4; ++i) {
-        auto e = static_cast<float>(packed[i]);
-        result.elements[i] = e / 255.f;
-    }
-    return { result };
-}
-
-CONSTANT_FUNCTION(Unpack4xI8)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<int8_t, 4>>(argument);
-    ConstantVector result(4);
-    for (unsigned i = 0; i < 4; ++i)
-        result.elements[i] = static_cast<int32_t>(packed[i]);
-    return { result };
-}
-
-CONSTANT_FUNCTION(Unpack4xU8)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<uint8_t, 4>>(argument);
-    ConstantVector result(4);
-    for (unsigned i = 0; i < 4; ++i)
-        result.elements[i] = static_cast<uint32_t>(packed[i]);
-    return { result };
-}
-
-CONSTANT_FUNCTION(Unpack2x16snorm)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<int16_t, 2>>(argument);
-    ConstantVector result(2);
-    for (unsigned i = 0; i < 2; ++i) {
-        auto e = static_cast<float>(packed[i]);
-        result.elements[i] = std::max(e / 32767.f, -1.f);
-    }
-    return { result };
-}
-
-CONSTANT_FUNCTION(Unpack2x16unorm)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<uint16_t, 2>>(argument);
-    ConstantVector result(2);
-    for (unsigned i = 0; i < 2; ++i) {
-        auto e = static_cast<float>(packed[i]);
-        result.elements[i] = e / 65535.f;
-    }
-    return { result };
-}
-
-CONSTANT_FUNCTION(Unpack2x16float)
-{
-    UNUSED_PARAM(resultType);
-    auto argument = std::get<uint32_t>(arguments[0]);
-    auto packed = bitwise_cast<std::array<half, 2>>(argument);
-    ConstantVector result(2);
-    for (unsigned i = 0; i < 2; ++i)
-        result.elements[i] = static_cast<float>(packed[i]);
-    return { result };
-}
+//CONSTANT_FUNCTION(Unpack4x8snorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<int8_t, 4>>(argument);
+//    ConstantVector result(4);
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = static_cast<float>(packed[i]);
+//        result.elements[i] = std::max(e / 127.f, -1.f);
+//    }
+//    return { result };
+//}
+//
+//CONSTANT_FUNCTION(Unpack4x8unorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<uint8_t, 4>>(argument);
+//    ConstantVector result(4);
+//    for (unsigned i = 0; i < 4; ++i) {
+//        auto e = static_cast<float>(packed[i]);
+//        result.elements[i] = e / 255.f;
+//    }
+//    return { result };
+//}
+//
+//CONSTANT_FUNCTION(Unpack4xI8)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<int8_t, 4>>(argument);
+//    ConstantVector result(4);
+//    for (unsigned i = 0; i < 4; ++i)
+//        result.elements[i] = static_cast<int32_t>(packed[i]);
+//    return { result };
+//}
+//
+//CONSTANT_FUNCTION(Unpack4xU8)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<uint8_t, 4>>(argument);
+//    ConstantVector result(4);
+//    for (unsigned i = 0; i < 4; ++i)
+//        result.elements[i] = static_cast<uint32_t>(packed[i]);
+//    return { result };
+//}
+
+//CONSTANT_FUNCTION(Unpack2x16snorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<int16_t, 2>>(argument);
+//    ConstantVector result(2);
+//    for (unsigned i = 0; i < 2; ++i) {
+//        auto e = static_cast<float>(packed[i]);
+//        result.elements[i] = std::max(e / 32767.f, -1.f);
+//    }
+//    return { result };
+//}
+//
+//CONSTANT_FUNCTION(Unpack2x16unorm)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<uint16_t, 2>>(argument);
+//    ConstantVector result(2);
+//    for (unsigned i = 0; i < 2; ++i) {
+//        auto e = static_cast<float>(packed[i]);
+//        result.elements[i] = e / 65535.f;
+//    }
+//    return { result };
+//}
+//
+//CONSTANT_FUNCTION(Unpack2x16float)
+//{
+//    UNUSED_PARAM(resultType);
+//    auto argument = std::get<uint32_t>(arguments[0]);
+//    auto packed = bitwise_cast<std::array<half, 2>>(argument);
+//    ConstantVector result(2);
+//    for (unsigned i = 0; i < 2; ++i)
+//        result.elements[i] = static_cast<float>(packed[i]);
+//    return { result };
+//}
 
 CONSTANT_FUNCTION(Bitcast)
 {
diff --git a/Source/WebGPU/WGSL/TypeDeclarations.h b/Source/WebGPU/WGSL/TypeDeclarations.h
new file mode 100644
index 000000000000..2bf47789891a
--- /dev/null
+++ b/Source/WebGPU/WGSL/TypeDeclarations.h
@@ -0,0 +1,6114 @@
+//#include "AST.h"
+//using namespace WGSL
+
+introduceType(AST::Identifier::make("vec2f"_s), m_types.vectorType(2, m_types.f32Type()));
+introduceType(AST::Identifier::make("vec2i"_s), m_types.vectorType(2, m_types.i32Type()));
+introduceType(AST::Identifier::make("vec2u"_s), m_types.vectorType(2, m_types.u32Type()));
+introduceType(AST::Identifier::make("mat2x2f"_s), m_types.matrixType(2, 2, m_types.f32Type()));
+introduceType(AST::Identifier::make("mat2x3f"_s), m_types.matrixType(2, 3, m_types.f32Type()));
+introduceType(AST::Identifier::make("mat2x4f"_s), m_types.matrixType(2, 4, m_types.f32Type()));
+introduceType(AST::Identifier::make("vec3f"_s), m_types.vectorType(3, m_types.f32Type()));
+introduceType(AST::Identifier::make("vec3i"_s), m_types.vectorType(3, m_types.i32Type()));
+introduceType(AST::Identifier::make("vec3u"_s), m_types.vectorType(3, m_types.u32Type()));
+introduceType(AST::Identifier::make("mat3x2f"_s), m_types.matrixType(3, 2, m_types.f32Type()));
+introduceType(AST::Identifier::make("mat3x3f"_s), m_types.matrixType(3, 3, m_types.f32Type()));
+introduceType(AST::Identifier::make("mat3x4f"_s), m_types.matrixType(3, 4, m_types.f32Type()));
+introduceType(AST::Identifier::make("vec4f"_s), m_types.vectorType(4, m_types.f32Type()));
+introduceType(AST::Identifier::make("vec4i"_s), m_types.vectorType(4, m_types.i32Type()));
+introduceType(AST::Identifier::make("vec4u"_s), m_types.vectorType(4, m_types.u32Type()));
+introduceType(AST::Identifier::make("mat4x2f"_s), m_types.matrixType(4, 2, m_types.f32Type()));
+introduceType(AST::Identifier::make("mat4x3f"_s), m_types.matrixType(4, 3, m_types.f32Type()));
+introduceType(AST::Identifier::make("mat4x4f"_s), m_types.matrixType(4, 4, m_types.f32Type()));
+
+{
+auto result = m_overloadedOperations.add("!"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantNot,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ! :: (Bool) -> Bool
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ! :: <N>(Vector<N, Bool>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("||"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantOr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // || :: (Bool, Bool) -> Bool
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("&&"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantAnd,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // && :: (Bool, Bool) -> Bool
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("|"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantBitwiseOr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // | :: (Bool, Bool) -> Bool
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // | :: <N>(Vector<N, Bool>, Vector<N, Bool>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // | :: <T is Integer>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // | :: <T is Integer, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("&"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantBitwiseAnd,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // & :: <AS, T, AM>(Reference<AS, T, AM>) -> Pointer<AS, T, AM>
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractReference { AS, allocateAbstractType(T), AM }));
+    candidate.result = allocateAbstractType(AbstractPointer { AS, allocateAbstractType(T), AM });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // & :: (Bool, Bool) -> Bool
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // & :: <N>(Vector<N, Bool>, Vector<N, Bool>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // & :: <T is Integer>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // & :: <T is Integer, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("-"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantMinus,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is SignedNumber>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::SignedNumber };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is SignedNumber, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::SignedNumber };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is Number, N>(Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is Number, N>(T, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // - :: <T is Float, C, R>(Matrix<C, R, T>, Matrix<C, R, T>) -> Matrix<C, R, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("+"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantAdd,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // + :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // + :: <T is Number, N>(Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // + :: <T is Number, N>(T, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // + :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // + :: <T is Float, C, R>(Matrix<C, R, T>, Matrix<C, R, T>) -> Matrix<C, R, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("*"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantMultiply,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <AS, T, AM>(Pointer<AS, T, AM>) -> Reference<AS, T, AM>
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(T), AM }));
+    candidate.result = allocateAbstractType(AbstractReference { AS, allocateAbstractType(T), AM });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Number, N>(Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Number, N>(T, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Number, C, R>(Matrix<C, R, T>, T) -> Matrix<C, R, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Number, C, R>(T, Matrix<C, R, T>) -> Matrix<C, R, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Float, C, R>(Matrix<C, R, T>, Vector<C, T>) -> Vector<R, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { C, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { R, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Float, C, R>(Vector<R, T>, Matrix<C, R, T>) -> Vector<C, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { R, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { C, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // * :: <T is Float, C, R, K>(Matrix<K, R, T>, Matrix<C, K, T>) -> Matrix<C, R, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    ValueVariable K { 2 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.valueVariables.append(K);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { K, R, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, K, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("/"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantDivide,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // / :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // / :: <T is Number, N>(Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // / :: <T is Number, N>(T, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // / :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("%"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantModulo,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // % :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // % :: <T is Number, N>(Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // % :: <T is Number, N>(T, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // % :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("=="_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantEqual,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // == :: <T is Scalar>(T, T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // == :: <T is Scalar, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("!="_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantNotEqual,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // != :: <T is Scalar>(T, T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // != :: <T is Scalar, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("<"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantLt,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // < :: <T is Number>(T, T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // < :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("<="_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantLtEq,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // <= :: <T is Number>(T, T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // <= :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add(">"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantGt,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // > :: <T is Number>(T, T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // > :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add(">="_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantGtEq,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // >= :: <T is Number>(T, T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // >= :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, Bool>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("~"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantBitwiseNot,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ~ :: <T is Integer>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ~ :: <T is Integer, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("^"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantBitwiseXor,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ^ :: <T is Integer>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ^ :: <T is Integer, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Integer };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("<<"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantBitwiseShiftLeft,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // << :: <S is Integer>(S, U32) -> S
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Integer };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(S);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // << :: <S is Integer, N>(Vector<N, S>, Vector<N, U32>) -> Vector<N, S>
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Integer };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(S);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.u32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(S) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add(">>"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Operator,
+    .mustUse = true,
+    .constantFunction = constantBitwiseShiftRight,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // >> :: <S is Integer>(S, U32) -> S
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Integer };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(S);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // >> :: <S is Integer, N>(Vector<N, S>, Vector<N, U32>) -> Vector<N, S>
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Integer };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(S);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.u32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(S) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("bool"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantBool,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // bool :: () -> Bool
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // bool :: <T is ConcreteScalar>(T) -> Bool
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("i32"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantI32,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // i32 :: () -> I32
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.i32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // i32 :: <T is ConcreteScalar>(T) -> I32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.i32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("u32"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantU32,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // u32 :: () -> U32
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // u32 :: <T is ConcreteScalar>(T) -> U32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("f32"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantF32,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // f32 :: () -> F32
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // f32 :: <T is ConcreteScalar>(T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("vec2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantVec2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec2 :: <T is ConcreteScalar>() -> Vector<2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec2 :: <T is Scalar>(T) -> Vector<2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec2 :: <T is ConcreteScalar, S is Scalar>(Vector<2, S>) -> Vector<2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    TypeVariable S { 1, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec2 :: <S is Scalar>(Vector<2, S>) -> Vector<2, S>
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Scalar };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec2 :: <T is Scalar>(T, T) -> Vector<2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec2 :: () -> vector[2, AbstractInt]
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.abstractIntType()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("vec3"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantVec3,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <T is ConcreteScalar>() -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <T is Scalar>(T) -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <T is ConcreteScalar, S is Scalar>(Vector<3, S>) -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    TypeVariable S { 1, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <S is Scalar>(Vector<3, S>) -> Vector<3, S>
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Scalar };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <T is Scalar>(T, T, T) -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <T is Scalar>(Vector<2, T>, T) -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: <T is Scalar>(T, Vector<2, T>) -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec3 :: () -> vector[3, AbstractInt]
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.vectorType(3, m_types.abstractIntType()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("vec4"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantVec4,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is ConcreteScalar>() -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(T) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is ConcreteScalar, S is Scalar>(Vector<4, S>) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteScalar };
+    TypeVariable S { 1, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <S is Scalar>(Vector<4, S>) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Scalar };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(T, T, T, T) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(T, Vector<2, T>, T) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(T, T, Vector<2, T>) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(Vector<2, T>, T, T) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(Vector<2, T>, Vector<2, T>) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(Vector<3, T>, T) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: <T is Scalar>(T, Vector<3, T>) -> Vector<4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // vec4 :: () -> vector[4, AbstractInt]
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.abstractIntType()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat2x2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat2x2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x2 :: <T is ConcreteFloat>() -> Matrix<2, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x2 :: <T is ConcreteFloat, S is Float>(Matrix<2, 2, S>) -> Matrix<2, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x2 :: <T is Float>(Matrix<2, 2, T>) -> Matrix<2, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x2 :: <T is Float>(T, T, T, T) -> Matrix<2, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x2 :: <T is Float>(Vector<2, T>, Vector<2, T>) -> Matrix<2, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat2x3"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat2x3,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x3 :: <T is ConcreteFloat>() -> Matrix<2, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x3 :: <T is ConcreteFloat, S is Float>(Matrix<2, 3, S>) -> Matrix<2, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x3 :: <T is Float>(Matrix<2, 3, T>) -> Matrix<2, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x3 :: <T is Float>(T, T, T, T, T, T) -> Matrix<2, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x3 :: <T is Float>(Vector<3, T>, Vector<3, T>) -> Matrix<2, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat2x4"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat2x4,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x4 :: <T is ConcreteFloat>() -> Matrix<2, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x4 :: <T is ConcreteFloat, S is Float>(Matrix<2, 4, S>) -> Matrix<2, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x4 :: <T is Float>(Matrix<2, 4, T>) -> Matrix<2, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x4 :: <T is Float>(T, T, T, T, T, T, T, T) -> Matrix<2, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat2x4 :: <T is Float>(Vector<4, T>, Vector<4, T>) -> Matrix<2, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(2) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat3x2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat3x2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x2 :: <T is ConcreteFloat>() -> Matrix<3, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x2 :: <T is ConcreteFloat, S is Float>(Matrix<3, 2, S>) -> Matrix<3, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x2 :: <T is Float>(Matrix<3, 2, T>) -> Matrix<3, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x2 :: <T is Float>(T, T, T, T, T, T) -> Matrix<3, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x2 :: <T is Float>(Vector<2, T>, Vector<2, T>, Vector<2, T>) -> Matrix<3, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat3x3"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat3x3,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x3 :: <T is ConcreteFloat>() -> Matrix<3, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x3 :: <T is ConcreteFloat, S is Float>(Matrix<3, 3, S>) -> Matrix<3, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x3 :: <T is Float>(Matrix<3, 3, T>) -> Matrix<3, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x3 :: <T is Float>(T, T, T, T, T, T, T, T, T) -> Matrix<3, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x3 :: <T is Float>(Vector<3, T>, Vector<3, T>, Vector<3, T>) -> Matrix<3, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat3x4"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat3x4,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x4 :: <T is ConcreteFloat>() -> Matrix<3, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x4 :: <T is ConcreteFloat, S is Float>(Matrix<3, 4, S>) -> Matrix<3, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x4 :: <T is Float>(Matrix<3, 4, T>) -> Matrix<3, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x4 :: <T is Float>(T, T, T, T, T, T, T, T, T, T, T, T) -> Matrix<3, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat3x4 :: <T is Float>(Vector<4, T>, Vector<4, T>, Vector<4, T>) -> Matrix<3, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(3) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat4x2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat4x2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x2 :: <T is ConcreteFloat>() -> Matrix<4, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x2 :: <T is ConcreteFloat, S is Float>(Matrix<4, 2, S>) -> Matrix<4, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x2 :: <T is Float>(Matrix<4, 2, T>) -> Matrix<4, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x2 :: <T is Float>(T, T, T, T, T, T, T, T) -> Matrix<4, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x2 :: <T is Float>(Vector<2, T>, Vector<2, T>, Vector<2, T>, Vector<2, T>) -> Matrix<4, 2, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat4x3"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat4x3,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x3 :: <T is ConcreteFloat>() -> Matrix<4, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x3 :: <T is ConcreteFloat, S is Float>(Matrix<4, 3, S>) -> Matrix<4, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x3 :: <T is Float>(Matrix<4, 3, T>) -> Matrix<4, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x3 :: <T is Float>(T, T, T, T, T, T, T, T, T, T, T, T) -> Matrix<4, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x3 :: <T is Float>(Vector<3, T>, Vector<3, T>, Vector<3, T>, Vector<3, T>) -> Matrix<4, 3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mat4x4"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Constructor,
+    .mustUse = true,
+    .constantFunction = constantMat4x4,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x4 :: <T is ConcreteFloat>() -> Matrix<4, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x4 :: <T is ConcreteFloat, S is Float>(Matrix<4, 4, S>) -> Matrix<4, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    TypeVariable S { 1, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x4 :: <T is Float>(Matrix<4, 4, T>) -> Matrix<4, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x4 :: <T is Float>(T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T) -> Matrix<4, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mat4x4 :: <T is Float>(Vector<4, T>, Vector<4, T>, Vector<4, T>, Vector<4, T>) -> Matrix<4, 4, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { AbstractValue { static_cast<unsigned>(4) }, AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("all"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAll,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // all :: <N>(Vector<N, Bool>) -> Bool
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // all :: <N>(Bool) -> Bool
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("any"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAny,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // any :: <N>(Vector<N, Bool>) -> Bool
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // any :: <N>(Bool) -> Bool
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(m_types.boolType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("select"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSelect,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // select :: <T is Scalar>(T, T, Bool) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // select :: <T is Scalar, N>(Vector<N, T>, Vector<N, T>, Bool) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(m_types.boolType()));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // select :: <T is Scalar, N>(Vector<N, T>, Vector<N, T>, Vector<N, Bool>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Scalar };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.boolType()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("arrayLength"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // arrayLength :: <T>(Pointer<AddressSpace::Storage, Array<T>, AccessMode::Read>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable T { 0 };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AbstractValue { static_cast<unsigned>(AddressSpace::Storage) }, allocateAbstractType(AbstractArray { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::Read) } }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // arrayLength :: <T>(Pointer<AddressSpace::Storage, Array<T>, AccessMode::ReadWrite>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable T { 0 };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AbstractValue { static_cast<unsigned>(AddressSpace::Storage) }, allocateAbstractType(AbstractArray { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("acos"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAcos,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // acos :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // acos :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("asin"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAsin,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // asin :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // asin :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atan"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAtan,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atan :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atan :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("cos"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCos,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // cos :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // cos :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("sin"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSin,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sin :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sin :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("tan"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantTan,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // tan :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // tan :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("acosh"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAcosh,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // acosh :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // acosh :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("asinh"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAsinh,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // asinh :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // asinh :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atanh"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAtanh,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atanh :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atanh :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("cosh"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCosh,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // cosh :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // cosh :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("sinh"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSinh,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sinh :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sinh :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("tanh"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantTanh,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // tanh :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // tanh :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("abs"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAbs,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // abs :: <T is Number>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // abs :: <T is Number, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atan2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantAtan2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atan2 :: <T is Float>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atan2 :: <T is Float, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("ceil"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCeil,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ceil :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ceil :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("clamp"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantClamp,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // clamp :: <T is Number>(T, T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // clamp :: <T is Number, N>(Vector<N, T>, Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("countLeadingZeros"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCountLeadingZeros,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // countLeadingZeros :: <T is ConcreteInteger>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // countLeadingZeros :: <T is ConcreteInteger, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("countOneBits"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCountOneBits,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // countOneBits :: <T is ConcreteInteger>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // countOneBits :: <T is ConcreteInteger, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("countTrailingZeros"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCountTrailingZeros,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // countTrailingZeros :: <T is ConcreteInteger>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // countTrailingZeros :: <T is ConcreteInteger, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("cross"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantCross,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // cross :: <T is Float>(Vector<3, T>, Vector<3, T>) -> Vector<3, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("degrees"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantDegrees,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // degrees :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // degrees :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("determinant"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantDeterminant,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // determinant :: <T is Float, C>(Matrix<C, C, T>) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, C, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("distance"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantDistance,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // distance :: <T is Float>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // distance :: <T is Float, N>(Vector<N, T>, Vector<N, T>) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dot"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantDot,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dot :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("exp"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantExp,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // exp :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // exp :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("exp2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantExp2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // exp2 :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // exp2 :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("extractBits"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantExtractBits,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // extractBits :: (I32, U32, U32) -> I32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.i32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(m_types.i32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // extractBits :: <N>(Vector<N, I32>, U32, U32) -> Vector<N, I32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.i32Type()) }));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.i32Type()) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // extractBits :: (U32, U32, U32) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // extractBits :: <N>(Vector<N, U32>, U32, U32) -> Vector<N, U32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.u32Type()) }));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.u32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("faceForward"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFaceForward,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // faceForward :: <T is Float, N>(Vector<N, T>, Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("firstLeadingBit"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFirstLeadingBit,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // firstLeadingBit :: (I32) -> I32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.i32Type()));
+    candidate.result = allocateAbstractType(m_types.i32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // firstLeadingBit :: <N>(Vector<N, I32>) -> Vector<N, I32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.i32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.i32Type()) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // firstLeadingBit :: (U32) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // firstLeadingBit :: <N>(Vector<N, U32>) -> Vector<N, U32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.u32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.u32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("firstTrailingBit"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFirstTrailingBit,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // firstTrailingBit :: <T is ConcreteInteger>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // firstTrailingBit :: <T is ConcreteInteger, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("floor"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFloor,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // floor :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // floor :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("fma"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFma,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fma :: <T is Float>(T, T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fma :: <T is Float, N>(Vector<N, T>, Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("fract"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFract,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fract :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fract :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("frexp"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantFrexp,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (F32) -> frexpResult[F32, I32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.f32Type(), m_types.i32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (AbstractFloat) -> frexpResult[AbstractFloat, AbstractInt]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.abstractFloatType()));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.abstractFloatType(), m_types.abstractIntType()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (vector[2, F32]) -> frexpResult[vector[2, F32], vector[2, I32]]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.vectorType(2, m_types.f32Type()), m_types.vectorType(2, m_types.i32Type())));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (vector[2, AbstractFloat]) -> frexpResult[vector[2, AbstractFloat], vector[2, AbstractInt]]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.abstractFloatType())));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.vectorType(2, m_types.abstractFloatType()), m_types.vectorType(2, m_types.abstractIntType())));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (vector[3, F32]) -> frexpResult[vector[3, F32], vector[3, I32]]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.vectorType(3, m_types.f32Type()), m_types.vectorType(3, m_types.i32Type())));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (vector[3, AbstractFloat]) -> frexpResult[vector[3, AbstractFloat], vector[3, AbstractInt]]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.abstractFloatType())));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.vectorType(3, m_types.abstractFloatType()), m_types.vectorType(3, m_types.abstractIntType())));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (vector[4, F32]) -> frexpResult[vector[4, F32], vector[4, I32]]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(4, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.vectorType(4, m_types.f32Type()), m_types.vectorType(4, m_types.i32Type())));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // frexp :: (vector[4, AbstractFloat]) -> frexpResult[vector[4, AbstractFloat], vector[4, AbstractInt]]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(4, m_types.abstractFloatType())));
+    candidate.result = allocateAbstractType(m_types.frexpResultType(m_types.vectorType(4, m_types.abstractFloatType()), m_types.vectorType(4, m_types.abstractIntType())));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("insertBits"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantInsertBits,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // insertBits :: <T is ConcreteInteger>(T, T, U32, U32) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // insertBits :: <T is ConcreteInteger, N>(Vector<N, T>, Vector<N, T>, U32, U32) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.u32Type()));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("inverseSqrt"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantInverseSqrt,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // inverseSqrt :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // inverseSqrt :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("ldexp"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantLdexp,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ldexp :: <T is ConcreteFloat>(T, I32) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.i32Type()));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ldexp :: (AbstractFloat, AbstractInt) -> AbstractFloat
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.abstractFloatType()));
+    candidate.parameters.append(allocateAbstractType(m_types.abstractIntType()));
+    candidate.result = allocateAbstractType(m_types.abstractFloatType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ldexp :: <T is ConcreteFloat, N>(Vector<N, T>, Vector<N, I32>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteFloat };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.i32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // ldexp :: <N>(Vector<N, AbstractFloat>, Vector<N, AbstractInt>) -> Vector<N, AbstractFloat>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.abstractFloatType()) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.abstractIntType()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.abstractFloatType()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("length"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantLength,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // length :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // length :: <T is Float, N>(Vector<N, T>) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("log"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantLog,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // log :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // log :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("log2"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantLog2,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // log2 :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // log2 :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("max"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantMax,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // max :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // max :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("min"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantMin,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // min :: <T is Number>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // min :: <T is Number, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Number };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("mix"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantMix,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mix :: <T is Float>(T, T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mix :: <T is Float, N>(Vector<N, T>, Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // mix :: <T is Float, N>(Vector<N, T>, Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("modf"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantModf,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+}
+
+{
+auto result = m_overloadedOperations.add("normalize"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantNormalize,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // normalize :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("pow"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantPow,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // pow :: <T is Float>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // pow :: <T is Float, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("quantizeToF16"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantQuantizeToF16,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // quantizeToF16 :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // quantizeToF16 :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("radians"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantRadians,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // radians :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // radians :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("reflect"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantReflect,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // reflect :: <T is Float, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("refract"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantRefract,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // refract :: <T is Float, N>(Vector<N, T>, Vector<N, T>, T) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("reverseBits"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantReverseBits,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // reverseBits :: <T is ConcreteInteger>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // reverseBits :: <T is ConcreteInteger, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("round"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantRound,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // round :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // round :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("saturate"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSaturate,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // saturate :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // saturate :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("sign"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSign,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sign :: <T is SignedNumber>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::SignedNumber };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sign :: <T is SignedNumber, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::SignedNumber };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("smoothstep"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSmoothstep,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // smoothstep :: <T is Float>(T, T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // smoothstep :: <T is Float, N>(Vector<N, T>, Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("sqrt"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantSqrt,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sqrt :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // sqrt :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("step"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantStep,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // step :: <T is Float>(T, T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // step :: <T is Float, N>(Vector<N, T>, Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("transpose"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantTranspose,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // transpose :: <T is Float, C, R>(Matrix<C, R, T>) -> Matrix<R, C, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable C { 0 };
+    ValueVariable R { 1 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(C);
+    candidate.valueVariables.append(R);
+    candidate.parameters.append(allocateAbstractType(AbstractMatrix { C, R, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractMatrix { R, C, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("trunc"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = constantTrunc,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // trunc :: <T is Float>(T) -> T
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // trunc :: <T is Float, N>(Vector<N, T>) -> Vector<N, T>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::Float };
+    ValueVariable N { 0 };
+    candidate.typeVariables.append(T);
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(T) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dpdx"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdx :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdx :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dpdxCoarse"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdxCoarse :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdxCoarse :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dpdxFine"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdxFine :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdxFine :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dpdy"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdy :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdy :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dpdyCoarse"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdyCoarse :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdyCoarse :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("dpdyFine"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdyFine :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // dpdyFine :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("fwidth"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fwidth :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fwidth :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("fwidthCoarse"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fwidthCoarse :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fwidthCoarse :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("fwidthFine"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fwidthFine :: (F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // fwidthFine :: <N>(Vector<N, F32>) -> Vector<N, F32>
+    OverloadCandidate candidate;
+    ValueVariable N { 0 };
+    candidate.valueVariables.append(N);
+    candidate.parameters.append(allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) }));
+    candidate.result = allocateAbstractType(AbstractVector { N, allocateAbstractType(m_types.f32Type()) });
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureDimensions"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture1d, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture1d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <F, AM>(TextureStorage<Types::TextureStorage::Kind::TextureStorage1d, F, AM>) -> U32
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(F);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage1d, F, AM }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber, T is ConcreteInteger>(Texture<Types::Texture::Kind::Texture1d, S>, T) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture1d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2d, S>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2dArray, S>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureCube, S>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCube, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureCubeArray, S>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCubeArray, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureMultisampled2d, S>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureMultisampled2d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: (TextureDepth2d) -> vector[2, U32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: (TextureDepth2dArray) -> vector[2, U32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: (TextureDepthCube) -> vector[2, U32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: (TextureDepthCubeArray) -> vector[2, U32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: (TextureDepthMultisampled2d) -> vector[2, U32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthMultisampled2dType()));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <F, AM>(TextureStorage<Types::TextureStorage::Kind::TextureStorage2d, F, AM>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(F);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage2d, F, AM }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <F, AM>(TextureStorage<Types::TextureStorage::Kind::TextureStorage2dArray, F, AM>) -> vector[2, U32]
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(F);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage2dArray, F, AM }));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: (TextureExternal) -> vector[2, U32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureExternalType()));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber, T is ConcreteInteger>(Texture<Types::Texture::Kind::Texture2d, S>, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber, T is ConcreteInteger>(Texture<Types::Texture::Kind::Texture2dArray, S>, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber, T is ConcreteInteger>(Texture<Types::Texture::Kind::TextureCube, S>, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCube, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber, T is ConcreteInteger>(Texture<Types::Texture::Kind::TextureCubeArray, S>, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCubeArray, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <T is ConcreteInteger>(TextureDepth2d, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <T is ConcreteInteger>(TextureDepth2dArray, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <T is ConcreteInteger>(TextureDepthCube, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <T is ConcreteInteger>(TextureDepthCubeArray, T) -> vector[2, U32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(2, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture3d, S>) -> vector[3, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture3d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(3, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <F, AM>(TextureStorage<Types::TextureStorage::Kind::TextureStorage3d, F, AM>) -> vector[3, U32]
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(F);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage3d, F, AM }));
+    candidate.result = allocateAbstractType(m_types.vectorType(3, m_types.u32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureDimensions :: <S is Concrete32BitNumber, T is ConcreteInteger>(Texture<Types::Texture::Kind::Texture3d, S>, T) -> vector[3, U32]
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture3d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(3, m_types.u32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureGather"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <T is ConcreteInteger, S is Concrete32BitNumber>(T, Texture<Types::Texture::Kind::Texture2d, S>, Sampler, vector[2, F32]) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <T is ConcreteInteger, S is Concrete32BitNumber>(T, Texture<Types::Texture::Kind::Texture2d, S>, Sampler, vector[2, F32], vector[2, I32]) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <T is ConcreteInteger, S is Concrete32BitNumber, U is ConcreteInteger>(T, Texture<Types::Texture::Kind::Texture2dArray, S>, Sampler, vector[2, F32], U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::Concrete32BitNumber };
+    TypeVariable U { 2, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <T is ConcreteInteger, S is Concrete32BitNumber, U is ConcreteInteger>(T, Texture<Types::Texture::Kind::Texture2dArray, S>, Sampler, vector[2, F32], U, vector[2, I32]) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::Concrete32BitNumber };
+    TypeVariable U { 2, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <T is ConcreteInteger, S is Concrete32BitNumber>(T, Texture<Types::Texture::Kind::TextureCube, S>, Sampler, vector[3, F32]) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCube, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <T is ConcreteInteger, S is Concrete32BitNumber, U is ConcreteInteger>(T, Texture<Types::Texture::Kind::TextureCubeArray, S>, Sampler, vector[3, F32], U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::Concrete32BitNumber };
+    TypeVariable U { 2, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCubeArray, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: (TextureDepth2d, Sampler, vector[2, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: (TextureDepth2d, Sampler, vector[2, F32], vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: (TextureDepthCube, Sampler, vector[3, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <U is ConcreteInteger>(TextureDepth2dArray, Sampler, vector[2, F32], U) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable U { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <U is ConcreteInteger>(TextureDepth2dArray, Sampler, vector[2, F32], U, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable U { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGather :: <U is ConcreteInteger>(TextureDepthCubeArray, Sampler, vector[3, F32], U) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable U { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureGatherCompare"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGatherCompare :: (TextureDepth2d, SamplerComparison, vector[2, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGatherCompare :: (TextureDepth2d, SamplerComparison, vector[2, F32], F32, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGatherCompare :: <T is ConcreteInteger>(TextureDepth2dArray, SamplerComparison, vector[2, F32], T, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGatherCompare :: <T is ConcreteInteger>(TextureDepth2dArray, SamplerComparison, vector[2, F32], T, F32, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGatherCompare :: (TextureDepthCube, SamplerComparison, vector[3, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureGatherCompare :: <T is ConcreteInteger>(TextureDepthCubeArray, SamplerComparison, vector[3, F32], T, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureLoad"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, U is ConcreteInteger, S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture1d, S>, T, U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable U { 1, Constraints::ConcreteInteger };
+    TypeVariable S { 2, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(U);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture1d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, U is ConcreteInteger, S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2d, S>, Vector<2, T>, U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable U { 1, Constraints::ConcreteInteger };
+    TypeVariable S { 2, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(U);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, V is ConcreteInteger, U is ConcreteInteger, S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2dArray, S>, Vector<2, T>, V, U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable V { 1, Constraints::ConcreteInteger };
+    TypeVariable U { 2, Constraints::ConcreteInteger };
+    TypeVariable S { 3, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(V);
+    candidate.typeVariables.append(U);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(V));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, U is ConcreteInteger, S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture3d, S>, Vector<3, T>, U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable U { 1, Constraints::ConcreteInteger };
+    TypeVariable S { 2, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(U);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture3d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, U is ConcreteInteger, S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureMultisampled2d, S>, Vector<2, T>, U) -> Vector<4, S>
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable U { 1, Constraints::ConcreteInteger };
+    TypeVariable S { 2, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(U);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureMultisampled2d, allocateAbstractType(S) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(S) });
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, U is ConcreteInteger>(TextureDepth2d, Vector<2, T>, U) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable U { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, S is ConcreteInteger, U is ConcreteInteger>(TextureDepth2dArray, Vector<2, T>, S, U) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::ConcreteInteger };
+    TypeVariable U { 2, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger, U is ConcreteInteger>(TextureDepthMultisampled2d, Vector<2, T>, U) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable U { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(U);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthMultisampled2dType()));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(U));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureLoad :: <T is ConcreteInteger>(TextureExternal, Vector<2, T>) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureExternalType()));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureNumLayers"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLayers :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2dArray, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLayers :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureCubeArray, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCubeArray, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLayers :: (TextureDepth2dArray) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLayers :: (TextureDepthCubeArray) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLayers :: <F, AM>(TextureStorage<Types::TextureStorage::Kind::TextureStorage2dArray, F, AM>) -> U32
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    ValueVariable AM { 1 };
+    candidate.valueVariables.append(F);
+    candidate.valueVariables.append(AM);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage2dArray, F, AM }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureNumLevels"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture1d, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture1d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2d, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture2dArray, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture2dArray, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::Texture3d, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::Texture3d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureCube, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCube, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureCubeArray, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureCubeArray, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: (TextureDepth2d) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: (TextureDepth2dArray) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: (TextureDepthCube) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumLevels :: (TextureDepthCubeArray) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureNumSamples"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumSamples :: <S is Concrete32BitNumber>(Texture<Types::Texture::Kind::TextureMultisampled2d, S>) -> U32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::Concrete32BitNumber };
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTexture { Types::Texture::Kind::TextureMultisampled2d, allocateAbstractType(S) }));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureNumSamples :: (TextureDepthMultisampled2d) -> U32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthMultisampled2dType()));
+    candidate.result = allocateAbstractType(m_types.u32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSample"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (texture[Types::Texture::Kind::Texture1d, F32], Sampler, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture1d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (texture[Types::Texture::Kind::TextureCube, F32], Sampler, vector[3, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCube, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], vector[3, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: <T is ConcreteInteger>(texture[Types::Texture::Kind::TextureCubeArray, F32], Sampler, vector[3, F32], T) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCubeArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (TextureDepth2d, Sampler, vector[2, F32]) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (TextureDepth2d, Sampler, vector[2, F32], vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: <T is ConcreteInteger>(TextureDepth2dArray, Sampler, vector[2, F32], T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: <T is ConcreteInteger>(TextureDepth2dArray, Sampler, vector[2, F32], T, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: (TextureDepthCube, Sampler, vector[3, F32]) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSample :: <T is ConcreteInteger>(TextureDepthCubeArray, Sampler, vector[3, F32], T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSampleBias"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], F32, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, F32, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: (texture[Types::Texture::Kind::TextureCube, F32], Sampler, vector[3, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCube, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], F32, vector[3, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBias :: <T is ConcreteInteger>(texture[Types::Texture::Kind::TextureCubeArray, F32], Sampler, vector[3, F32], T, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCubeArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSampleCompare"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompare :: (TextureDepth2d, SamplerComparison, vector[2, F32], F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompare :: (TextureDepth2d, SamplerComparison, vector[2, F32], F32, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompare :: <T is ConcreteInteger>(TextureDepth2dArray, SamplerComparison, vector[2, F32], T, F32) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompare :: <T is ConcreteInteger>(TextureDepth2dArray, SamplerComparison, vector[2, F32], T, F32, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompare :: (TextureDepthCube, SamplerComparison, vector[3, F32], F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompare :: <T is ConcreteInteger>(TextureDepthCubeArray, SamplerComparison, vector[3, F32], T, F32) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSampleCompareLevel"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompareLevel :: (TextureDepth2d, SamplerComparison, vector[2, F32], F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompareLevel :: (TextureDepth2d, SamplerComparison, vector[2, F32], F32, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompareLevel :: <T is ConcreteInteger>(TextureDepth2dArray, SamplerComparison, vector[2, F32], T, F32) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompareLevel :: <T is ConcreteInteger>(TextureDepth2dArray, SamplerComparison, vector[2, F32], T, F32, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompareLevel :: (TextureDepthCube, SamplerComparison, vector[3, F32], F32) -> F32
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleCompareLevel :: <T is ConcreteInteger>(TextureDepthCubeArray, SamplerComparison, vector[3, F32], T, F32) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerComparisonType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSampleGrad"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], vector[2, F32], vector[2, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], vector[2, F32], vector[2, F32], vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, vector[2, F32], vector[2, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, vector[2, F32], vector[2, F32], vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], vector[3, F32], vector[3, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: (texture[Types::Texture::Kind::TextureCube, F32], Sampler, vector[3, F32], vector[3, F32], vector[3, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCube, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], vector[3, F32], vector[3, F32], vector[3, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleGrad :: <T is ConcreteInteger>(texture[Types::Texture::Kind::TextureCubeArray, F32], Sampler, vector[3, F32], T, vector[3, F32], vector[3, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCubeArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSampleLevel"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32], F32, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <T is ConcreteInteger>(texture[Types::Texture::Kind::Texture2dArray, F32], Sampler, vector[2, F32], T, F32, vector[2, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2dArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: (texture[Types::Texture::Kind::TextureCube, F32], Sampler, vector[3, F32], F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCube, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: (texture[Types::Texture::Kind::Texture3d, F32], Sampler, vector[3, F32], F32, vector[3, I32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture3d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <T is ConcreteInteger>(texture[Types::Texture::Kind::TextureCubeArray, F32], Sampler, vector[3, F32], T, F32) -> vector[4, F32]
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::TextureCubeArray, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.f32Type()));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <T is ConcreteInteger>(TextureDepth2d, Sampler, vector[2, F32], T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <T is ConcreteInteger>(TextureDepth2d, Sampler, vector[2, F32], T, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <S is ConcreteInteger, T is ConcreteInteger>(TextureDepth2dArray, Sampler, vector[2, F32], S, T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::ConcreteInteger };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <S is ConcreteInteger, T is ConcreteInteger>(TextureDepth2dArray, Sampler, vector[2, F32], S, T, vector[2, I32]) -> F32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::ConcreteInteger };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepth2dArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.i32Type())));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <T is ConcreteInteger>(TextureDepthCube, Sampler, vector[3, F32], T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleLevel :: <S is ConcreteInteger, T is ConcreteInteger>(TextureDepthCubeArray, Sampler, vector[3, F32], S, T) -> F32
+    OverloadCandidate candidate;
+    TypeVariable S { 0, Constraints::ConcreteInteger };
+    TypeVariable T { 1, Constraints::ConcreteInteger };
+    candidate.typeVariables.append(S);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(m_types.textureDepthCubeArrayType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(3, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.f32Type());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureSampleBaseClampToEdge"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBaseClampToEdge :: (TextureExternal, Sampler, vector[2, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureExternalType()));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureSampleBaseClampToEdge :: (texture[Types::Texture::Kind::Texture2d, F32], Sampler, vector[2, F32]) -> vector[4, F32]
+    OverloadCandidate candidate;
+    candidate.parameters.append(allocateAbstractType(m_types.textureType(Types::Texture::Kind::Texture2d, m_types.f32Type())));
+    candidate.parameters.append(allocateAbstractType(m_types.samplerType()));
+    candidate.parameters.append(allocateAbstractType(m_types.vectorType(2, m_types.f32Type())));
+    candidate.result = allocateAbstractType(m_types.vectorType(4, m_types.f32Type()));
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("textureStore"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute, ShaderStage::Vertex },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureStore :: <F, T is ConcreteInteger>(TextureStorage<Types::TextureStorage::Kind::TextureStorage1d, F, AccessMode::Write>, T, Vector<4, ChannelFormat<F>>) -> Void
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.valueVariables.append(F);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage1d, F, AbstractValue { static_cast<unsigned>(AccessMode::Write) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(AbstractChannelFormat { F }) }));
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureStore :: <F, T is ConcreteInteger>(TextureStorage<Types::TextureStorage::Kind::TextureStorage2d, F, AccessMode::Write>, Vector<2, T>, Vector<4, ChannelFormat<F>>) -> Void
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.valueVariables.append(F);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage2d, F, AbstractValue { static_cast<unsigned>(AccessMode::Write) } }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(AbstractChannelFormat { F }) }));
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureStore :: <F, T is ConcreteInteger, S is ConcreteInteger>(TextureStorage<Types::TextureStorage::Kind::TextureStorage2dArray, F, AccessMode::Write>, Vector<2, T>, S, Vector<4, ChannelFormat<F>>) -> Void
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    TypeVariable S { 1, Constraints::ConcreteInteger };
+    candidate.valueVariables.append(F);
+    candidate.typeVariables.append(T);
+    candidate.typeVariables.append(S);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage2dArray, F, AbstractValue { static_cast<unsigned>(AccessMode::Write) } }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(2) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(S));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(AbstractChannelFormat { F }) }));
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // textureStore :: <F, T is ConcreteInteger>(TextureStorage<Types::TextureStorage::Kind::TextureStorage3d, F, AccessMode::Write>, Vector<3, T>, Vector<4, ChannelFormat<F>>) -> Void
+    OverloadCandidate candidate;
+    ValueVariable F { 0 };
+    TypeVariable T { 0, Constraints::ConcreteInteger };
+    candidate.valueVariables.append(F);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractTextureStorage { Types::TextureStorage::Kind::TextureStorage3d, F, AbstractValue { static_cast<unsigned>(AccessMode::Write) } }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(3) }, allocateAbstractType(T) }));
+    candidate.parameters.append(allocateAbstractType(AbstractVector { AbstractValue { static_cast<unsigned>(4) }, allocateAbstractType(AbstractChannelFormat { F }) }));
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicLoad"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicLoad :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicStore"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicStore :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> Void
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicAdd"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicAdd :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicSub"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicSub :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicMax"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicMax :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicMin"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicMin :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicOr"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicOr :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicXor"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicXor :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("atomicExchange"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Fragment, ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // atomicExchange :: <AS, T>(Pointer<AS, Atomic<T>, AccessMode::ReadWrite>, T) -> T
+    OverloadCandidate candidate;
+    ValueVariable AS { 0 };
+    TypeVariable T { 0 };
+    candidate.valueVariables.append(AS);
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AS, allocateAbstractType(AbstractAtomic { allocateAbstractType(T) }), AbstractValue { static_cast<unsigned>(AccessMode::ReadWrite) } }));
+    candidate.parameters.append(allocateAbstractType(T));
+    candidate.result = allocateAbstractType(T);
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("storageBarrier"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // storageBarrier :: () -> Void
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("workgroupBarrier"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = false,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // workgroupBarrier :: () -> Void
+    OverloadCandidate candidate;
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+}
+
+{
+auto result = m_overloadedOperations.add("workgroupUniformLoad"_s, OverloadedDeclaration {
+    .kind = OverloadedDeclaration::Function,
+    .mustUse = true,
+    .constantFunction = nullptr,
+    .visibility = { ShaderStage::Compute },
+    .overloads = { }
+});
+ASSERT_UNUSED(result, result.isNewEntry);
+result.iterator->value.overloads.append(([&]() -> OverloadCandidate {
+    // workgroupUniformLoad :: <T>(Pointer<AddressSpace::Workgroup, T>) -> Void
+    OverloadCandidate candidate;
+    TypeVariable T { 0 };
+    candidate.typeVariables.append(T);
+    candidate.parameters.append(allocateAbstractType(AbstractPointer { AbstractValue { static_cast<unsigned>(AddressSpace::Workgroup) }, allocateAbstractType(T) }));
+    candidate.result = allocateAbstractType(m_types.voidType());
+    return candidate;
+}()));
+}
+
diff --git a/Source/WebGPU/WGSL/config.h b/Source/WebGPU/WGSL/config.h
index 7efc5774c392..2ce840504780 100644
--- a/Source/WebGPU/WGSL/config.h
+++ b/Source/WebGPU/WGSL/config.h
@@ -28,3 +28,5 @@
 #include <wtf/DisallowCType.h>
 
 #include <wtf/Platform.h>
+
+#include <functional>
diff --git a/Source/WebGPU/WGSL/wgslc.cpp b/Source/WebGPU/WGSL/wgslc.cpp
index 87d8f4b6d7b0..841bab128de5 100644
--- a/Source/WebGPU/WGSL/wgslc.cpp
+++ b/Source/WebGPU/WGSL/wgslc.cpp
@@ -26,15 +26,25 @@
 #include "config.h"
 
 #include "AST/ASTStringDumper.h"
+#include "ASTNode.h"
+#include "ASTDeclaration.h"
+#include "AST.h"
 #include "WGSL.h"
 #include "WGSLShaderModule.h"
+#include "CallGraph.h"
 #include <wtf/DataLog.h>
 #include <wtf/FileSystem.h>
 #include <wtf/WTFProcess.h>
+#include <sys/shm.h>
+
+#define LIBAFL_EXIT_ID "__LIBAFL_EXIT_ID"
+#ifdef __AFL_COMPILER
+__AFL_FUZZ_INIT();
+#endif
 
 static NO_RETURN void printUsageStatement(bool help = false)
 {
-    fprintf(stderr, "Usage: wgsl [options] <file> <entrypoint>\n");
+    fprintf(stderr, "Usage: wgsl [options] <file>\n");
     fprintf(stderr, "  -h|--help  Prints this help message\n");
     fprintf(stderr, "  --dump-ast-after-checking  Dumps the AST after parsing and checking\n");
     fprintf(stderr, "  --dump-ast-at-end  Dumps the AST after generating code\n");
@@ -52,19 +62,19 @@ public:
     }
 
     const char* file() const { return m_file; }
-    const char* entrypoint() const { return m_entrypoint; }
     bool dumpASTAfterCheck() const { return m_dumpASTAfterCheck; }
     bool dumpASTAtEnd() const { return m_dumpASTAtEnd; }
     bool dumpGeneratedCode() const { return m_dumpGeneratedCode; }
+    bool writeMSL() const { return m_writeMSL; }
 
 private:
     void parseArguments(int, char**);
 
     const char* m_file { nullptr };
-    const char* m_entrypoint { nullptr };
     bool m_dumpASTAfterCheck { false };
     bool m_dumpASTAtEnd { false };
     bool m_dumpGeneratedCode { false };
+    bool m_writeMSL { false };
 };
 
 void CommandLine::parseArguments(int argc, char** argv)
@@ -89,36 +99,27 @@ void CommandLine::parseArguments(int argc, char** argv)
             continue;
         }
 
+        if (!strcmp(arg, "--write-msl")) {
+            m_writeMSL = true;
+            continue;
+        }
+
         if (!m_file)
             m_file = arg;
-        else if (!m_entrypoint)
-            m_entrypoint = arg;
         else
             printUsageStatement(false);
     }
 
-    if (!m_file || !m_entrypoint)
+#ifndef __AFL_COMPILER
+    if (!m_file)
         printUsageStatement(false);
+#endif
 }
 
-static int runWGSL(const CommandLine& options)
+static int runWGSL(const CommandLine& options, const String& source)
 {
     WGSL::Configuration configuration;
 
-
-    String fileName = String::fromLatin1(options.file());
-    auto handle = FileSystem::openFile(fileName, FileSystem::FileOpenMode::Read);
-    if (!FileSystem::isHandleValid(handle)) {
-        FileSystem::closeFile(handle);
-        dataLogLn("Failed to open ", fileName);
-        return EXIT_FAILURE;
-    }
-
-    auto readResult = FileSystem::readEntireFile(handle);
-    FileSystem::closeFile(handle);
-    auto source = emptyString();
-    if (readResult.has_value())
-        source = String::fromUTF8WithLatin1Fallback(readResult->data(), readResult->size());
     auto checkResult = WGSL::staticCheck(source, std::nullopt, configuration);
     if (auto* failedCheck = std::get_if<WGSL::FailedCheck>(&checkResult)) {
         for (const auto& error : failedCheck->errors)
@@ -130,28 +131,36 @@ static int runWGSL(const CommandLine& options)
     if (options.dumpASTAfterCheck())
         WGSL::AST::dumpAST(shaderModule);
 
-    String entrypointName = String::fromLatin1(options.entrypoint());
-    auto prepareResult = WGSL::prepare(shaderModule, entrypointName, std::nullopt);
+    buildCallGraph(shaderModule);
 
-    if (auto* error = std::get_if<WGSL::Error>(&prepareResult)) {
-        dataLogLn(*error);
-        return EXIT_FAILURE;
-    }
+    for (auto& e: shaderModule->callGraph().entrypoints()) {
+        auto prepareResult = WGSL::prepare(shaderModule, e.function.name().id(), std::nullopt);
 
-    auto& result = std::get<WGSL::PrepareResult>(prepareResult);
-    if (entrypointName != "_"_s && !result.entryPoints.contains(entrypointName)) {
-        dataLogLn("WGSL source does not contain entrypoint named '", entrypointName, "'");
-        return EXIT_FAILURE;
-    }
+        if (auto* error = std::get_if<WGSL::Error>(&prepareResult)) {
+            printf("prepare error\n");
+            continue;
+        }
+        auto& result = std::get<WGSL::PrepareResult>(prepareResult);
 
-    HashMap<String, WGSL::ConstantValue> constantValues;
-    auto msl = WGSL::generate(shaderModule, result, constantValues);
+        HashMap<String, WGSL::ConstantValue> constantValues;
+        auto msl = WGSL::generate(shaderModule, result, constantValues);
 
-    if (options.dumpASTAtEnd())
-        WGSL::AST::dumpAST(shaderModule);
+        if (options.dumpASTAtEnd())
+            WGSL::AST::dumpAST(shaderModule);
 
-    if (options.dumpGeneratedCode())
-        printf("%s", msl.utf8().data());
+        if (options.dumpGeneratedCode())
+            printf("%s", msl.utf8().data());
+
+        if (options.writeMSL()) {
+            auto fileName = String::fromLatin1(options.file()) + "_" + e.function.name().id() + ".msl";
+            auto handle = FileSystem::openFile(fileName, FileSystem::FileOpenMode::ReadWrite);
+            if (!FileSystem::isHandleValid(handle)) {
+                FileSystem::closeFile(handle);
+            }
+            FileSystem::writeToFile(handle, msl.utf8().data(), msl.utf8().length());
+            FileSystem::closeFile(handle);
+        }
+    }
 
     return EXIT_SUCCESS;
 }
@@ -161,5 +170,54 @@ int main(int argc, char** argv)
     WTF::initializeMainThread();
 
     CommandLine commandLine(argc, argv);
-    return runWGSL(commandLine);
+
+#ifdef __AFL_COMPILER
+    char* exit_code = NULL;
+    if (const char* shmid_str = getenv(LIBAFL_EXIT_ID)) {
+        int shmid = atoi(shmid_str);
+        void* addr = shmat(shmid, NULL, 0);
+        if (addr == (void *) -1) {
+          fprintf(stderr, "shmat failed\n");
+          exit(-1);
+        }
+        else {
+          exit_code = (char*)addr;
+        }
+    }
+    else {
+      fprintf(stderr, "env LIBAFL_EXIT_ID not set\n");
+      exit(-1);
+    }
+#endif
+
+#ifdef __AFL_HAVE_MANUAL_CONTROL
+    __AFL_INIT();
+#endif
+
+#ifdef __AFL_COMPILER
+    unsigned char *buf = __AFL_FUZZ_TESTCASE_BUF;
+    while (__AFL_LOOP(10000)) {
+        size_t len = (size_t)__AFL_FUZZ_TESTCASE_LEN;
+        auto source = String::fromUTF8WithLatin1Fallback(buf, len);
+        exit_code[0] = (runWGSL(commandLine, source) == EXIT_SUCCESS) ? 0 : 1;
+        exit_code[1] = 1;
+    }
+    return EXIT_SUCCESS;
+#else
+    String fileName = String::fromLatin1(commandLine.file());
+    auto handle = FileSystem::openFile(fileName, FileSystem::FileOpenMode::Read);
+    if (!FileSystem::isHandleValid(handle)) {
+        FileSystem::closeFile(handle);
+        dataLogLn("Failed to open ", fileName);
+        return EXIT_FAILURE;
+    }
+
+    auto readResult = FileSystem::readEntireFile(handle);
+    FileSystem::closeFile(handle);
+    auto source = emptyString();
+    if (readResult.has_value())
+        source = String::fromUTF8WithLatin1Fallback(readResult->data(), readResult->size());
+
+    return runWGSL(commandLine, source);
+#endif
 }
diff --git a/Source/bmalloc/bmalloc/BAssert.h b/Source/bmalloc/bmalloc/BAssert.h
index 843bc210665b..1a8700ecd4d6 100644
--- a/Source/bmalloc/bmalloc/BAssert.h
+++ b/Source/bmalloc/bmalloc/BAssert.h
@@ -59,6 +59,7 @@
 #if BASAN_ENABLED
 #define BCRASH() __builtin_trap()
 #else
+//#error "need asan"
 
 #if defined(__GNUC__) // GCC or Clang
 #define BCRASH() do { \
diff --git a/Tools/Scripts/webkitperl/BuildSubproject.pm b/Tools/Scripts/webkitperl/BuildSubproject.pm
index 2f93f90631c1..35b7d1301e3c 100644
--- a/Tools/Scripts/webkitperl/BuildSubproject.pm
+++ b/Tools/Scripts/webkitperl/BuildSubproject.pm
@@ -181,7 +181,7 @@ if (isCMakeBuild()) {
     unless (isAnyWindows()) {
         # By default we build using all of the available CPUs
         $makeArgs .= ($makeArgs ? " " : "") . "-j" . numberOfCPUs() if $makeArgs !~ /-j\s*\d+/;
-        $buildTarget = "jsc testb3 testair testapi testmasm testdfg $makeArgs";
+        $buildTarget = "jsc testb3 testair testapi testmasm testdfg wgslfuzz $makeArgs";
     } elsif (canUseNinja()) {
         $buildTarget .= "jsc testapi testmasm";
     }
diff --git a/Source/WebGPU/WGSL/GlobalVariableRewriter.cpp b/Source/WebGPU/WGSL/GlobalVariableRewriter.cpp
index 452d2c373e4d..9b0e8f105d1d 100644
--- a/Source/WebGPU/WGSL/GlobalVariableRewriter.cpp
+++ b/Source/WebGPU/WGSL/GlobalVariableRewriter.cpp
@@ -1251,7 +1251,16 @@ Vector<unsigned> RewriteGlobalVariables::insertStructs(const UsedResources& used
                 .webBinding = global.resource->binding,
                 .visibility = m_stage,
                 .bindingMember = bindingMemberForGlobal(global),
-                .name = global.declaration->name()
+                .name = global.declaration->name(),
+               .vertexArgumentBufferIndex = std::nullopt,
+               .vertexArgumentBufferSizeIndex = std::nullopt,
+               .vertexBufferDynamicOffset = std::nullopt,
+               .fragmentArgumentBufferIndex = std::nullopt,
+               .fragmentArgumentBufferSizeIndex = std::nullopt,
+               .fragmentBufferDynamicOffset = std::nullopt,
+               .computeArgumentBufferIndex = std::nullopt,
+               .computeArgumentBufferSizeIndex = std::nullopt,
+               .computeBufferDynamicOffset = std::nullopt,
             };
 
             auto bufferSizeIt = m_bufferLengthMap.find(global.declaration);
